#+title: CodeAcademy Flask
#+date: <2023-01-30 19:48>
#+description: CodeAcademy Flask notes
#+filetags: python codeacademy flask
#+OPTIONS: toc:2
#+OPTIONS: num:t
#+OPTIONS: ^:nil

* Įžanga į Flask

Flask yra populiariausias Python microframework. Jeigu projektas nėra
labai didelis, arba tiesiog norime pasidaryti kažkokį GUI per
naršyklę, kažką greitai prototipuoti, Flask yra labai geras
pasirinkimas. Su flask yra pakankamai paprasta kurti API's. Ši
paskaita bus greita įžanga, kitose nagrinėsime išsamiau.

Flask galima įdiegti su pip naudojant ~pip install flask~.

** Kaip sukurti minimalią svetainę:

#+begin_src python
from flask import Flask

app = Flask(__name__)

@app.route("/")
def home():
    return "<h1>Čia mano naujas puslapis</h1>"

if __name__ == "__main__":
    app.run(debug=True):
#+end_src

** Kaip puslapyje atvaizduoti įvestą kintamąjį:

#+begin_src python
from flask import Flask

app = Flask(__name__)

@app.route("/<name>")
def user(name):
    return f"Labas, {name}"

if __name__ == "__main__":
    app.run()
#+end_src

** Kaip sukurti ir panaudoti HTML šabloną:

main.py:

#+begin_src python
from flask import Flask, render_template

app = Flask(__name__)

@app.route("/")
def user():
    return render_template("index.html")

if __name__ == "__main__":
    app.run()
#+end_src

templates/index.html:

#+begin_src html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Mano Puslapis</title>
</head>
<body>
<h1>Labas, pasauli!</h1>
</body>
</html>
#+end_src

Įdėkime į šabloną šiek tiek logikos:

#+begin_src html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Skaičiavimai</title>
</head>
<body>
<h1>Skaičiavimai: </h1>
{%for x in range(10)%}
{%if x % 2 == 0 %}
<p>{{x}}</p>
{% endif %}
{%endfor%}
</body>
</html>
#+end_src

** Kaip kintamuosius perkelti į šabloną:

main.py

#+begin_src python
from flask import Flask, render_template

app = Flask(__name__)

@app.route("/")
def home():
    vardai = ['Jonas', 'Antanas', 'Petras']
    return render_template("index.html", sarasas=vardai)

if __name__ == "__main__":
    app.run()
#+end_src

templates/index.html

#+begin_src html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sarašas</title>
</head>
<body>
<h1>Žmonių sarašas: </h1>
{%for vardas in sarasas%}
<p>{{vardas}}</p>
{% endfor %}
</body>
</html>
#+end_src

** Kaip perduoti duomenis iš svetainės į programą:

main.py

#+begin_src python
from flask import Flask, request, render_template
app = Flask(__name__)

@app.route("/login", methods=['GET', 'POST'])
def login():
    if request.method == "POST":
        vardas = request.form['vardas']
        return render_template("greetings.html", vardas=vardas)
    else:
        return render_template("login.html")


if __name__ == "__main__":
    app.run()
#+end_src

templates/index.html

#+begin_src html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Prisijungimas</title>
</head>
<body>
<form action="#" method="post">
    <p>Vardas:</p>
    <p><input type="text" name="vardas"/></p>
    <p><input type="submit" value="submit"/></p>
</form>
</body>
</html>
#+end_src


templates/greetings.html

#+begin_src html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sveikiname</title>
</head>
<body>
<h1>{{vardas}}, sveikiname prisijungus!</h1>
</body>
</html>
#+end_src

** Naudojame base.html šabloną:

Failas templates/base.html:

#+begin_src html
<!DOCTYPE html>
<html lang="en">
<head>
  <title>Mano puslapis</title>
</head>
<body>
<div>
  <h1>Sveiki,</h1>
  <p>Čia yra mano super puslapis!</p>
</div>
<div class="container">
  {% block content %}{% endblock %}
</div>
<body>
</html>
#+end_src

Failas templates/login.html:

#+begin_src html
{% extends "base.html" %}
{% block content %}
<form action="#" method="post">
    <p>Vardas:</p>
    <p><input type="text" name="vardas"/></p>
    <p><input type="submit" value="submit"/></p>
</form>
{% endblock %}
#+end_src

Failas templates/greetings.html:

#+begin_src html
{% extends "base.html" %}
{% block content %}
<h1>{{vardas}}, sveikiname prisijungus!</h1>
{% endblock %}
#+end_src

** Stiliui panaudojame "Bootstrap":

Faile base.html:

#+begin_src html
<!DOCTYPE html>
<html lang="en">
<head>
  <title>Mano puslapis</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js"></script>
</head>
<body>

<!-- Navigation -->
<nav class="navbar navbar-expand-lg navbar-light bg-light static-top mb-5 shadow">
  <div class="container">
    <a class="navbar-brand" href="#">
    Mano puslapis</a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        <li class="nav-item">
          <a class="nav-link" href="/login">Prisijungti</a>
        </li>
      </ul>
    </div>
  </div>
</nav>

<div class="jumbotron text-center">
  <h1>Sveiki,</h1>
  <p>Čia yra mano super puslapis!</p>
</div>

<div class="container">
{% block content %}{% endblock %}
</div>

</body>
</html>
#+end_src

** Užduotys
*** 1 užduotis
Sukurti programą, kuri turėtų statinį puslapį, pvz. localhost:5000 su
norimu tekstu (rekomenduojama naudoti šablonus)

main.py

#+begin_src python
from flask import Flask, render_template

app = Flask(__name__)

@app.route("/")
def home():
    return render_template("home.html")

if __name__ == "__main__":
    app.run(debug=True)
#+end_src

template/home.html

#+begin_src html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Labas</title>
</head>
<body>
    <h1>Norimas tekstas</h1>
</body>
</html>
#+end_src

#+attr_html: :width 600px
#+ATTR_ORG: :width 600
[[./static/images/1.png]]

*** 2 užduotis

Sukurti programą, kuri įvedus norimą žodį adreso eilutėje (po /
simbolio) ir paspaudus ENTER, atspausdintų jį penkis kartus.

Still not sure where this is useful.

main.py

#+begin_src python
from flask import Flask, render_template

app = Flask(__name__)

@app.route("/<word>")
def word(word):
    return render_template("word.html", word = word)

if __name__ == "__main__":
    app.run(debug=True)
#+end_src

templates/word.html

#+begin_src html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Žodžiai</title>
</head>
<body>
    {% for x in range(5) %}
        {{word}}
    {% endfor %}
</body>
</html>
#+end_src


#+attr_html: :width 600px
#+ATTR_ORG: :width 600
[[./static/images/2.png]]

*** 3 užduotis
Sukurti programą, kuri puslapyje localhost:5000/keliamieji parodytų
visus keliamuosius metus nuo 1900 iki 2100 metų.

Cool use of calendar.

main.py

#+begin_src python
from flask import Flask, render_template
import calendar

app = Flask(__name__)

@app.route("/keliamieji")
def leap():
    return render_template("leap.html", calendar = calendar)

if __name__ == "__main__":
    app.run(debug=True)
#+end_src

templates/leap.html

#+begin_src html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Leap</title>
</head>
<body>
    {% for year in range(1900, 2100) %}
    {% if calendar.isleap(year) %}
    {{year}}
    {% endif %}
    {% endfor %}
</body>
</html>
#+end_src

#+attr_html: :width 600px
#+ATTR_ORG: :width 600
[[./static/images/3.png]]

*** 4 užduotis
Sukurti programą, kuri leistų įvesti metus ir paspaudus patvirtinimo
mygtuką parodytų, ar jie yra keliamieji.

main.py

#+begin_src python
  from flask import Flask, render_template, request
  import calendar

  app = Flask(__name__)


  @app.route("/")
  def home():
      return "<h1>Labas, cia yra pradinis</h1><p>Paziurek kas slepiasi po http://localhost:5000/arkeliamieji</p>"


  @app.route("/arkeliamieji", methods=["GET", "POST"])
  def isleap():
      if request.method == "GET":
          return render_template("getyear.html")
      elif request.method == "POST":
          year = request.form["year"]
          return render_template("isleap.html", year=int(year), calendar=calendar)


  if __name__ == "__main__":
      app.run(debug=True)
#+end_src

templates/getyear.html

#+begin_src html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Get Year</title>
</head>
<body>
<form action="#" method="post">
    <p>Metai:</p>
    <p><input type="text" name="year"/></p>
    <p><input type="submit" value="Patikrinti"/></p>
</form>
</body>
</html>
#+end_src

templates/isleap.html

#+begin_src html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Is Leap</title>
</head>
<body>
    {% if calendar.isleap(year) %}
    <p>Keliamieji</p>
    {% else %}
    <p>Nekeliamieji</p>
    {% endif %}
</body>
</html>
#+end_src

#+attr_html: :width 600px
#+ATTR_ORG: :width 600
[[./static/images/4.gif]]


*** 5 užduotis (papildomai)

Patobulinti anksčiau kurtą biudžeto programą, panaudojant Flask
(bendravimui su vartotoju) ir SQLAlchemy (darbui su duomenų baze,
kurioje bus saugomi pajamų ir išlaidų įrašai).

Run db.py file first to create a database:

db.py

#+begin_src python
import datetime
import os
from sqlalchemy import Column, Integer, String, Float, DateTime, create_engine
from sqlalchemy.ext.declarative import declarative_base

engine = create_engine("sqlite:///.db")
Base = declarative_base()


class Projektas(Base):
    __tablename__ = "Projektas"
    id = Column(Integer, primary_key=True)
    name = Column("Pavadinimas", String)
    price = Column("Kaina", Float)
    created_date = Column("Sukūrimo data", DateTime, default=datetime.datetime.utcnow)

    # aprasom taip pat kaip paprasta klase. Asocijuojam su klase. Kad zinotu i kuri collumn deti kintamaji
    # created_date matai neidetas apacioje, nes nereikia jo mum patiem irasyti, jis turi default reiksme
    # jeigu noretum irasyti ir keisti - tuomet prie init turetum prirasyti
    def __init__(self, name, price):
        self.name = name
        self.price = price

    # Kada kvieciam klase su query, kad ja israsytu ir KAIP israsytu apibudinam cia
    def __repr__(self):
        return f"{self.id} {self.name} - {self.price}: {self.created_date}"


# kviecia connectiona ir sukuria visas lenteles jeigu jos neegzistuoja. Jos neupdeitins.
Base.metadata.create_all(engine)
#+end_src

main.py

#+begin_src python
  import os
  from flask import Flask, request, render_template, url_for, redirect
  from flask_sqlalchemy import SQLAlchemy

  if __name__ == "__main__":
      from models.irasas import Irasas

  basedir = os.path.abspath(os.path.dirname(__file__))
  app = Flask(__name__)


  app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///" + os.path.join(basedir, "biudzetas.db")
  app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
  db = SQLAlchemy(app)

  db.create_all()


  @app.route("/prideti", methods=["GET", "POST"])
  def prideti():
      if request.method == "POST":
          suma = request.form["suma"]
          info = request.form["info"]
          irasas = Irasas(suma, info)
          db.session.add(irasas)
          db.session.commit()
          return sarasas()
      elif request.method == "GET":
          return render_template("prideti.html")


  @app.route("/")
  def sarasas():
      biudzetas = Irasas.query.all()
      return render_template("sarasas.html", biudzetas=biudzetas)


  @app.route("/balansas")
  def balansas():
      biudzetas = db.session.query(Irasas).all()
      balansas = 0
      for irasas in biudzetas:
          balansas += irasas.suma
      return render_template("balansas.html", balansas=balansas)


  @app.route("/irasas_delete/<int:id>")
  def irasas_delete(id):
      uzklausa = db.session.query(Irasas).get(id)
      db.session.delete(uzklausa)
      db.session.commit()
      return redirect(url_for("sarasas"))


  @app.route("/irasas_update/<int:id>", methods=["GET", "POST"])
  def irasas_update(id):
      if request.method == "POST":
          irasas = db.session.query(Irasas).get(id)
          irasas.suma = request.form["suma"]
          irasas.info = request.form["info"]
          db.session.commit()
          return redirect(url_for("sarasas"))
      elif request.method == "GET":
          irasas = db.session.query(Irasas).get(id)
          return render_template("redaguoti.html", irasas=irasas)


  if __name__ == "__main__":
      app.run(debug=True)
#+end_src

models/irasas.py

#+begin_src python
from main import db


class Irasas(db.Model):
    __tablename__ = "Irasas"
    id = db.Column(db.Integer, primary_key=True)
    suma = db.Column("Suma", db.Float)
    info = db.Column("Info", db.String(120))

    def __init__(self, suma, info):
        self.suma = suma
        self.info = info

    def __repr__(self):
        return f"{self.id}: suma - {self.suma}, info - {self.info}"


db.create_all()
#+end_src

templates/balansas.html

#+begin_src html
{% extends "base.html" %}
{% block content %}
    <h1>Balansas: </h1>
    <p>{{balansas}}</p>
{% endblock %}
#+end_src

templates/prideti.html

#+begin_src html
{% extends "base.html" %}
{% block content %}
<form action="#" method="post">
    <p>Suma:</p>
    <p><input type="text" name="suma"/></p>
    <p>Info:</p>
    <p><input type="text" name="info"/></p>
    <p><input type="submit" value="Įvesti"/></p>
</form>
{% endblock %}
#+end_src

templates/redaguoti.html

#+begin_src html
{% extends "base.html" %}
{% block content %}
<form action="#" method="post">
    <p>Suma:</p>
    <p><input type="text" name="suma" value={{irasas.suma}} /></p>
    <p>Info:</p>
    <p><input type="text" name="info" value={{irasas.info}} /></p>
    <p><input type="submit" value="Įvesti"/></p>
</form>
{% endblock %}>
#+end_src

templates/sarasas.html

#+begin_src html
{% extends "base.html" %}
{% block content %}
<h1>Biudžeto įrašai: </h1>
{%for irasas in biudzetas%}
<p>{{irasas}}</p>
<a href="{{ url_for('irasas_delete', id=irasas['id']) }}">Ištrinti</a>
<a href="{{ url_for('irasas_update', id=irasas['id']) }}">Redaguoti</a>
<hr>
{% endfor %}
{% endblock %}
#+end_src

templates/base.html

#+begin_src html
<!DOCTYPE html>
<html lang="en">
<head>
  <title>Mano biudžetas</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js"></script>
</head>
<body>

<!-- Navigation -->
<nav class="navbar navbar-expand-lg navbar-light bg-light static-top mb-5 shadow">
  <div class="container">
    <a class="navbar-brand" href="#">
    <svg width="1em" height="1em" viewBox="0 0 16 16" class="bi bi-cash" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
    <path fill-rule="evenodd" d="M15 4H1v8h14V4zM1 3a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1V4a1 1 0 0 0-1-1H1z"/>
    <path d="M13 4a2 2 0 0 0 2 2V4h-2zM3 4a2 2 0 0 1-2 2V4h2zm10 8a2 2 0 0 1 2-2v2h-2zM3 12a2 2 0 0 0-2-2v2h2zm7-4a2 2 0 1 1-4 0 2 2 0 0 1 4 0z"/>
    </svg>
    Mano biudžetas</a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        <li class="nav-item">
          <a class="nav-link" href="/">Sąrašas</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="/balansas">Balansas</a>
        </li>
        <li class="nav-item">
            <a class="nav-link" href="/prideti">Pridėti</a>
        </li>
      </ul>
    </div>
  </div>
</nav>

<div class="container">
    {% block content %}{% endblock %}
</div>

</body>
</html>
#+end_src

Run main.py and open http://127.0.0.1:5000, see the magic :)

#+attr_html: :width 600px
#+ATTR_ORG: :width 600
[[./static/images/5.gif]]

~Important notes~!!

Jeigu norite paleistį šį projektą savo kompiuteryje, prieš tai
įsitikinkite, jog turite šiam projektui reikiamą flask_sqlalchemy
v2.5.1 versiją.

Tai galite padaryti savo virtualioje, šiam projektui skirtoje python
aplinkoje. Terminale tiesiog paleiskite šią komandą, kad įrašyti
reikiamą flask-sqlalchemy versiją:

~pip install flask-sqlalchemy==2.5.1~

Arba galite pasinaudoti requirements.txt. failiuku ir vos tik
parsisiuntus šį branch į savo kompiuterį ir pasiruošus virtualią
aplinką, susirašyti visas šiam projektui būtinas "dependencies" su šia
komanda:

~pip install -r requirements.txt~

requirements.txt

#+begin_src bash
click==8.1.3
Flask==2.2.2
Flask-SQLAlchemy==2.5.1
greenlet==2.0.1
importlib-metadata==6.0.0
itsdangerous==2.1.2
Jinja2==3.1.2
MarkupSafe==2.1.2
SQLAlchemy==1.4.46
Werkzeug==2.2.2
zipp==3.11.0
#+end_src

* Flask 1 dalis
** Susikurkime paprastą flask aplikaciją

app.py:

#+begin_src python
from flask import Flask, render_template
# iš flask bibliotekos importuojame klasę Flask ir f-ją render_template.
app = Flask(__name__)
# inicijuojame klasės Flask objektą, priskiriame kintamąjam app.

@app.route('/')
# įvelkame f-ją į flask dekoratorių. Be jo  funkcija būtų bereikšmė. Dekorato riaus parametruose nurodome, kad norėsime rezultato 127.0.0.1:8000/ url adrese."""

def index():
    return render_template('index.html')
# funkcijoje index nurodome, kad norėsime sugeneruoti index.html

if __name__ == '__main__':
  app.run(host='127.0.0.1', port=8000, debug=True)

# patikrinę, ar programa leidžiama ne iš kito failo, leidžiame mūsų app, su parametrais. debug = True klaidos atveju mums rodys informatyvias žinutes naršyklėje.
#+end_src

Komentaruose šiek tiek informacijos, kas vyksta. Dabar mums reikės
susikurti html šabloną. Flask šablonų ieško templates kataloge. :

#+begin_src html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Demo</title>
</head>
<body>
    <h1>Flask Flask Flask</h1>
</body>
</html>
#+end_src

Patikrinkime, ar veikia:

#+attr_html: :width 600px
#+ATTR_ORG: :width 600
[[./static/images/flask1_1.png]]


Logikos naudojimas šablonuose:

Už logiką šablonuose atsako Jinja2 šablonų generatorius (templating
engine), jis per savo sintaksę leidžia mums įterpti kintamuosius ir
logiką į html failus.

paruoškime paprastą žodynų sąrašą, kuris galės būti mūsų duomenų bazės
imitacija:

dictionary.py:

#+begin_src python
data =[{
    'data':'2020 01 01',
    'autorius': 'Autorius 1',
    'pavadinimas': 'Apie nieką',
    'tekstas': 'Zombie ipsum reversus ab viral inferno, nam rick grimes malum cerebro. De carne lumbering animata corpora quaeritis. Summus brains sit​​, morbo vel maleficia? De apocalypsi gorger omero undead survivor dictum mauris.'
},
{
    'data':'2020 02 01',
    'autorius': 'KITAS AUTORIUS',
    'pavadinimas': 'Apie zombius',
    'tekstas': 'Zombie ipsum reversus ab viral inferno, nam rick grimes malum cerebro. De carne lumbering animata corpora quaeritis. Summus brains sit​​, morbo vel maleficia? De apocalypsi gorger omero undead survivor dictum mauris. '
},
{
    'data':'2020 03 01',
    'autorius': 'Dar kažkas',
    'pavadinimas': 'Braiiins!',
    'tekstas': 'Zombie ipsum reversus ab viral inferno, nam rick grimes malum cerebro. De carne lumbering animata corpora quaeritis. Summus brains sit​​, morbo vel maleficia? De apocalypsi gorger omero undead survivor dictum mauris.'
}]
#+end_src


Pagrindiniame faile importuokime šį kintamąjį ir perduokime į šabloną:

app.py:

#+begin_src python
from flask import Flask, render_template
from dictionary import data # IMPORTUOJAME
app = Flask(__name__)


@app.route('/')

def index():
    return render_template('index.html', data=data) # PERDUODAME Į ŠABLONĄ

if __name__ == '__main__':
  app.run(host='127.0.0.1', port=8000, debug=True)
#+end_src

Dabar dirbsime su šablonu. Pradžiai tiesiog perduokime kintamąjį į
body:

#+begin_src html
<body>
    <h1>Straipsniai:</h1>
    {{ data }}
</body>
#+end_src

#+attr_html: :width 600px
#+ATTR_ORG: :width 600
[[./static/images/flask1_2.png]]

Čia yra grubus žodynų sąrašo perdavimas, jį ir matome. Pabandykime tai
paversti straipsnių puslapiu:

#+begin_src html
<body>
    <h1>Straipsniai</h1>
    <br><br>
    {% for straipsnis in data %}
    <h3>{{ straipsnis['pavadinimas'] }}</h3>
    <p>{{ straipsnis['data'] }}, {{ straipsnis['autorius'] }}</p>
    <hr>
    <p>{{ straipsnis['tekstas'] }}</p>
    <hr>
    {% endfor %}
</body>
#+end_src

#+attr_html: :width 600px
#+ATTR_ORG: :width 600
[[./static/images/flask1_3.png]]

Matome, kaip galime iteruoti per duomenis html'e. Pamėginkime įtraukti
if logiką. Pradžiai papildykime 'duomenų bazę'. Kiekviename žodyne
įtraukime 'status'. Dalies statusas bus 'published', dalies
'unpublished':

#+begin_src python
{
    'data':'2020 01 01',
    'autorius': 'Autorius 1',
    'pavadinimas': 'Apie nieką',
    'tekstas': 'Zombie ipsum reversus ab viral inferno, nam rick grimes malum cerebro. De carne lumbering animata corpora quaeritis. Summus brains sit​​, morbo vel maleficia? De apocalypsi gorger omero undead survivor dictum mauris.',
    'status': 'published'
}, # ir t.t.
#+end_src

įtraukime if logiką į šabloną:

#+begin_src html
<body>
    <h1>Straipsniai</h1>
    <br>
    {% for straipsnis in data %}
    {% if straipsnis['status'] == 'published' %}
    <h3>{{ straipsnis['pavadinimas'] }}</h3>
    <p>{{ straipsnis['data'] }}, <i>{{ straipsnis['autorius'] }}</i></p>
    <hr>
    <p>{{ straipsnis['tekstas'] }}</p>
    <br><br>
    {% endif %}
    {% endfor %}
</body>
#+end_src

#+attr_html: :width 600px
#+ATTR_ORG: :width 600
[[./static/images/flask1_4.png]]

Matome, kad straipsnis su statusu != 'published' nebuvo publikuotas.
Kaip ir python'e, galima naudoti {%elif %} ir {% else %}. Pvz.:


#+begin_src html
<body>
    <h1>Straipsniai</h1>
    <br>
    {% for straipsnis in data %}
    {% if straipsnis['status'] == 'published' %}
    <h3>{{ straipsnis['pavadinimas'] }}</h3>
    <p>{{ straipsnis['data'] }}, <i>{{ straipsnis['autorius'] }}</i></p>
    <hr>
    <p>{{ straipsnis['tekstas'] }}</p>
    <br><br>
    {% else %}
    <h3>{{ straipsnis['pavadinimas'] }} - <i>Publikavimas laikinai išjungtas</i></h3>
    <br><br>
    {% endif %}
    {% endfor %}
</body>
#+end_src

#+attr_html: :width 600px
#+ATTR_ORG: :width 600
[[./static/images/flask1_5.png]]

Paveldėjimas šablonuose

Dažniausiai interneto svetainės turi struktūrą, kai kiekviename
puslapyje atsikartoja tam tikri komponentai. Tai gali būti titulinė
puslapio dalis, <head> komponentai, navigacijos panelė, footer'is,
nuorodos į CSS, JavaScript ir pan. Jinja2 turi mechanizmą, leidžiantį
mums kiekvieną kartą nerašyti į šabloną šių komponentų, t.y. išsaugoti
juos atskirai ir naudoti tik nuorodas į juos. Pabandykime pritaikyti
praktikoje.

Pasiskolinkime standartinį išdėstymą iš [[https://github.com/StartBootstrap/startbootstrap-bare/blob/master/dist/index.html][čia]].

Tam, kad veiktų mobiliosios versijos navigacija, data-toggle ir
data-target reikia pakeisti data-bs-toggle ir data-bs-target.

Nusikopijuokime nuorodos HTML'ą į kokį nors html failą.

Pakeiskime lokalias css ir JavaScript nuorodas į [[https://getbootstrap.com/docs/4.3/getting-started/introduction/][Bootstrap CDN]]

Perkelkime savo <body> dalį vietoje tos dalies, kuri yra po komentaru
<!-- Page Content -->

senąjį failą pervadinkime backup.html, naująjį - index html.

Rezultatas atrodys maždaug taip:

#+attr_html: :width 600px
#+ATTR_ORG: :width 600
[[./static/images/flask1_6.png]]

Įsivaizduokime, kad mums reikės dar puslapio 'apie', galbūt dar keleto
puslapių ateityje. Visi jie turės tą patį bootstrap'ą, ir tą pačią
navigacijos panelę.

templates kataloge susikurkime failą base.html

visą turinį iš index.html nukopijuokime į naują base.html.

tuomet viską kas yra <div class="container"> viduje, triname ir
pakeičiame į {% block content %}{% endblock %}:

#+begin_src html
              </ul>
            </div>
        </div>
    </nav>

    <!-- Page Content -->

    <body>
        <div class="container">
            {% block content %}
            {% endblock %}
        </div>
    </body>


    <!-- Bootstrap core JavaScript -->
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
        integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"
        crossorigin="anonymous"></script>
#+end_src

Išsaugokime base.html.

index.html pertvarkykime taip:

#+begin_src html
{% extends "base.html" %}

{% block content %}

<h1>Straipsniai</h1>
<br>
{% for straipsnis in data %}
{% if straipsnis['status'] == 'published' %}
<h3>{{ straipsnis['pavadinimas'] }}</h3>
<p>{{ straipsnis['data'] }}, <i>{{ straipsnis['autorius'] }}</i></p>
<hr>
<p>{{ straipsnis['tekstas'] }}</p>
<br><br>
{% else %}
<h3>{{ straipsnis['pavadinimas'] }} - <i>Publikavimas laikinai išjungtas</i></h3>
<br><br>
{% endif %}
{% endfor %}

{% endblock %}
#+end_src


papildykime savo app.py nauju maršrutu:

#+begin_src python
@app.route('/about')
def about():
    return render_template('about.html')
#+end_src

base.html susiraskime navigacijoje nuorodą 'About', ir nukreipkime į
savo naująjį maršrutą:

#+begin_src html
<li class="nav-item">
    <a class="nav-link" href="/about">About</a>
</li>
susikurkime dar vieną šabloną, about.html:


{% extends "base.html" %}

{% block content %}

<h1>Apie</h1>
<p>Šiame puslapyje rasite labai daug naudingos informacijos apie beveik viską</p>

{% endblock %}
#+end_src

Svetainėje, paspaudę nuorodą atsidursime puslapyje "Apie":

#+attr_html: :width 600px
#+ATTR_ORG: :width 600
[[./static/images/flask1_7.png]]

[[https://github.com/CodeAcademy-Online/Python/tree/lesson-14][result here]].

* Flask 2 dalis
** Dinaminiai maršrutai ir formos
*** Dinaminiai maršrutai

Tęskime su praeitos paskaitos medžiaga. Įsivaizduokime, kad mums
reikės straipsnių sąrašo, su dalimi teksto, ir po kiekvienu sąrašo
elementu nuorodos 'skaityti toliau...'. Tokiose situacijose labai
praverčia dinaminiai maršrutai. Susikurkime naują maršrutą app.py:

#+begin_src python
@app.route('/<string:title>') # parametruose nurodomas kintamasis (title) ir jo tipas (string)
def article(title): # kintam1jį būtinai nurodykite ir funkcijos parametruose
    return render_template('article.html', title=title, data=data) # taip pat ir čia reikia jį perduoti
#+end_src

dabar pakoreguokime mūsų index.html:

#+begin_src html
{% extends "base.html" %}

{% block content %}

<h1>Straipsniai</h1>
<br>
{% for straipsnis in data %}
<h3>{{ straipsnis['pavadinimas'] }}</h3>
<p>{{ straipsnis['data'] }}, <i>{{ straipsnis['autorius'] }}</i></p>
<hr>
<p>{{ straipsnis['tekstas'][:30] }}<a href="{{ url_for('article', title=straipsnis['pavadinimas']) }}">...skaityti toliau</a></p>
<br><br>
{% endfor %}

{% endblock %}
#+end_src

panagrinėkime <p> bloką.

- {{ straipsnis['tekstas'][:30] }} - vietoje pilno teksto pasiliekame
  ištrauką pirmų 30ties simbolių

- nuorodoje naudojama url_for() yra pagalbinė Jinja funkcija. Į
  parametrus priima maršruto funkcijos pavadinimą. Paprastesniu
  atveju, url_for('about') nukreiptų į mūsų 'Apie' puslapį.

- {{ url_for('article', title=straipsnis['pavadinimas']) }} - šiuo
  atveju mes nurodėme, kad norime į 'article' ir kad jo parametruose
  esantis title būtų prilygintas straipsnio pavadinimui.

Mūsų straipsnių puslapis dabar atrodo taip:

#+attr_html: :width 300px
#+ATTR_ORG: :width 300
[[./static/images/flask2_1.png]]

Susikurkime tuščią article.html ir pažiūrėkime, kas vyksta:

article.html tuščias, todėl nėra jokio turinio. Tačiau URL eilutėje
matome, kad puslaio endpoint'as yra straipsnio pavadinimas. Padarykime
taip, kad matytumėm straipsnio turinį

article.html:

#+begin_src python
{% extends "base.html" %}

{% block content %}

{% for straipsnis in data %}
{% if straipsnis['pavadinimas'] == title %}

<h1>{{ straipsnis['pavadinimas'] }}</h1>
<p>{{ straipsnis['data'] }}, <i>{{ straipsnis['autorius'] }}</i></p>
<hr>
<p>{{ straipsnis['tekstas'] }}</p>
<br><br>

{% endif %}
{% endfor %}

{% endblock %}
#+end_src

išbandykime:

#+attr_html: :width 800px
#+ATTR_ORG: :width 600
[[./static/images/flask2_2.png]]
*** Formos

Formas flaske galima kurti dviem būdais. Aptarsime abu. Pirmas iš jų
būtų paprastos formos iš HTML duomenų surinkimas. Tinka įvairiems
testavimams, ne kritiniams duomenims apdoroti. Veikimo principas buvo
glaustai pademonstruotas įžangos skyriuje. Žinoma, tas formas galima
privesti iki profesionalaus lygmens, tačiau reikės nemažai papildomo
darbo.

sukurkime naują maršrutą:

#+begin_src python
@app.route('/add_article')
def add_article():
    return render_template('add_article.html')
#+end_src

papildykime index.html nuoroda po straipsniais "Rašyti straipsnį"

#+begin_src html
{% extends "base.html" %}

{% block content %}

<h1>Straipsniai</h1>
<br>
{% for straipsnis in data %}
<h3>{{ straipsnis['pavadinimas'] }}</h3>
<p>{{ straipsnis['data'] }}, <i>{{ straipsnis['autorius'] }}</i></p>
<hr>
<p>{{ straipsnis['tekstas'][:30] }}<a href="{{ url_for('article', title=straipsnis['pavadinimas']) }}">...skaityti toliau</a></p>
<br><br>
{% endfor %}
<h1><a href="{{ url_for('add_article') }}"> Rašyti straipsnį</a></h1>
{% endblock %}
#+end_src

sukurkime naują šabloną add_article.html:

#+begin_src html
{% extends "base.html" %}

{% block content %}

<form action="/", method="post">
  <div class="form-group">
    <label for="autorius">Autorius</label>
    <input type="text" class="form-control" id="autorius" name="autorius">
  </div>
  <div class="form-group">
    <label for="pavadinimas">Pavadinimas</label>
    <input type="text" class="form-control" id="pavadinimas" name="pavadinimas">
  </div>
  <div class="form-group">
    <label for="date">Data</label>
    <input type="text" class="form-control" id="date" name="date">
  </div>
  <div class="form-group">
    <label for="tekstas">Example textarea</label>
    <textarea class="form-control" id="tekstas" name="tekstas" rows="3"></textarea>
  </div>
  <button type="submit" class="btn btn-primary">Išsaugoti</button>
</form>

{% endblock %}
#+end_src


užeikime į "Rašyti straipsnį" nuorodą:

#+attr_html: :width 600px
#+ATTR_ORG: :width 600
[[./static/images/flask2_3.png]]

Turime neveikiančią formą.

Prie importų iš flask pridėkime ~request~. Pakoreguokime index()
funkciją:

#+begin_src python
@app.route('/', methods=['GET', 'POST'])
def index():
    if request.method == 'POST':
        date = request.form['date']
        autorius = request.form['autorius']
        tekstas = request.form['tekstas']
        pavadinimas = request.form['pavadinimas']
        data.append({
            'data': date,
            'autorius': autorius,
            'pavadinimas': pavadinimas,
            'tekstas': tekstas,
            'status': 'published'
        })
    return render_template('index.html', data=data)
#+end_src


funkcijoje pasitikriname, ar yra 'post' užklausa, jeigu yra, tai
papildome mūsų "duomenų bazę" naujais duomenimis:

#+attr_html: :width 600px
#+ATTR_ORG: :width 600
[[./static/images/flask2_4.png]]

*** flask-wtf

Antras būdas tvarkytis su formomis yra trečios šalies bibliotekos
~flask_wtf~ naudojimas. Ji pasirūpina saugumo klausimais "out of the
box" ir yra industrijos standartas dirbant su flask. Pamėginsime
kontaktuose sukurti paprastą formą. Reikia šiek tiek pasiruošti:

- sukurkime naują tuščią maršrutą contact_us

- sukurkime naują tuščią šabloną tam maršrutui

- navigacijoje aktyvuokime nuorodą į contact_us

- sukurkime naują failą forms.py

- įsidiekime flask-wtf biblioteką (pip install flask-wtf)

forms.py:

#+begin_src python
from flask_wtf import FlaskForm
from wtforms import StringField, TextAreaField, SubmitField
from wtforms.validators import DataRequired, Length, Email


class ContactForm(FlaskForm):
    name = StringField('Vardas', [DataRequired()])
    email = StringField('El.paštas', [Email(message=('Neteisingas adresas.')), DataRequired()])
    body = TextAreaField('Jūsų pranešimas', [DataRequired(),
                                        Length(min=10,
                                        message=('Per trumpas tekstas.'))])
    submit = SubmitField('Submit')
#+end_src

Šį kartą mūsų forma aprašoma, kaip klasė. Visus laukų tipus ir
validatorius (patvirtintojus?..) reikia importuotis atskirai. Pvz.:
eilutę priskirtą kintamąjam body galima dekonstruoti taip:

TextAreaField - nurodome, kokio tipo formos lauką generuoti.

'Jūsų pranešimas' - formos lauko pavadinimas (label).

[DataRequired(), Length(min=10, message=('Per trumpas tekstas.'))]) -
sąraše yra validators - Nurodome kad laukas būtinas užpildyti, kad
minimum 10 simbolių, ir kokia klaidos žinutė.

Kokie yra galimi laukai, galima pažiūrėti [[https://wtforms.readthedocs.io/en/stable/fields/][čia]]. Kokie yra galimi
validators, galima pažiūrėti [[https://wtforms.readthedocs.io/en/stable/validators/][čia]].

pakoreguokime maršrutą:

#+begin_src python
@app.route('/contact_us', methods=['GET', 'POST'])
def contact_us():
    form = ContactForm()
    if form.validate_on_submit():
        return render_template('contact_success.html', form=form)
    return render_template('contact_us.html', form=form)
#+end_src

Pakoregavome contact_us maršrutą taip, kad jeigu forma sėkmingai
praėjo validaciją, nukreiptų mus į sėkmės puslapį.

pasidarykime šablonus - contact_us.html:

#+begin_src html
  {% extends "base.html" %}

  {% block content %}

    <form method="post" action="{{ url_for('contact_success') }}">
        {{ form.hidden_tag() }}
        <div class="form-group">
        {{ form.name.label(class="form-control-label") }}
        {{ form.name(class="form-control") }}
        </div>
        <div class="form-group">
        {{ form.email.label(class="form-control-label") }}
        {{ form.email(class="form-control") }}
        </div>
        <div class="form-group">
        {{ form.body.label(class="form-control-label") }}
        {{ form.body(class="form-control", rows="5") }}
        </div>
        {{ form.submit }}
    </form>
  {% endblock %}
#+end_src

reikėtų atkreipti dėmesį, kad Bootstrap klasės rašomos į kintamųjų
parametrus

ir sėkmės puslapiui - contact_success.html

#+begin_src html
{% extends "base.html" %}

{% block content %}

<h1>Forma užpildyta sėkmingai!</h1>
<p>Vardas: {{form.name.data}}</p>
<p>El. paštas: {{form.email.data}}</p>
<p>Tekstas:</p>
<p>{{form.body.data}}</p>

{% endblock %}
#+end_src

kadangi apie duomenų bazes kalbėsime sekančioje paskaitoje, su šiuo
labai nesistengėme, išgaudysime formos reikšmes į pliką HTML.

#+attr_html: :width 600px
#+ATTR_ORG: :width 600
[[./static/images/flask2_5.png]]

paspaudus 'Submit' mygtuką, mes niekur nenukreipiami, nes forma
nepraėjo validacijos filtrų. Būtų gerai, jeigu mus informuotų, kas
atsitiko. Reikia koreguoti formos šabloną:

#+begin_src html
{% extends "base.html" %}

{% block content %}

  <form method="post" action="#">
      {{ form.csrf_token }}
      <div class="form-group">
      {{ form.name.label(class="form-control-label") }}
      {{ form.name(class="form-control") }}
      {% if form.name.errors %}
        {% for error in form.name.errors %}
          <small><font color="red">{{ error }}</font></small>
        {% endfor %}
      {% endif %}
      </div>
      <div class="form-group">
      {{ form.email.label(class="form-control-label") }}
      {{ form.email(class="form-control") }}
      {% if form.email.errors %}
        {% for error in form.email.errors %}
          <small><font color="red">{{ error }}</font></small>
        {% endfor %}
      {% endif %}
      </div>
      <div class="form-group">
      {{ form.body.label(class="form-control-label") }}
      {{ form.body(class="form-control", rows="5") }}
      {% if form.body.errors %}
        {% for error in form.body.errors %}
          <small><font color="red">{{ error }}</font></small>
        {% endfor %}
      {% endif %}
      </div>
      {{ form.submit }}
  </form>

{% endblock %}
#+end_src

Atrodo painiai :) Tai tik po kiekvienu lauku nurodyta sąlyga, kad
jeigu tam laukui yra kažkokios klaidos, praiteruojame jas, ir
parašome, kas tai per klaida:

#+attr_html: :width 600px
#+ATTR_ORG: :width 600
[[./static/images/flask2_6.png]]

Na ir pagaliau pabandykime teisingai suvesti:

#+attr_html: :width 600px
#+ATTR_ORG: :width 600
[[./static/images/flask2_7.png]]

** Uzduotis
*** app.py

#+begin_src python
from flask import Flask, render_template, request, redirect, url_for, flash
from form import ContactForm


app = Flask(__name__)
app.config['SECRET_KEY'] = 'bet kokia simbolių eilutė'

@app.route('/', methods=['GET', 'POST'])
def form():
    form = ContactForm()
    if form.validate_on_submit():
        return render_template('success.html', form=form)
    return render_template('form.html', form=form)


if __name__ == '__main__':
  app.run(host='127.0.0.1', port=8000, debug=True)
#+end_src
*** form.py
#+begin_src python
from flask_wtf import FlaskForm
from wtforms import StringField, PasswordField, SelectField, SubmitField, BooleanField
from wtforms.validators import DataRequired, Length, Email, InputRequired


class ContactForm(FlaskForm):

    email = StringField('Vardas', [Email(message=('Neteisingas adresas.')), DataRequired(message='Lauką būtina užpildyti')])
    password = PasswordField('Slaptažodis', validators=[Length(min=8, message=('Per mažai simbolių!')), DataRequired(message='Lauką būtina užpildyti')])
    address1 = StringField('Adresas (pirma eilutė)', validators=[DataRequired(message=('Lauką būtina užpildyti')), Length(min=4, message=('Per mažai simbolių!'))])
    address2 = StringField('Adresas (antra eilutė)', validators=[Length(min=4, message=('Per mažai simbolių'))])
    city = StringField('Miestas', validators=[DataRequired(message='Lauką būtina užpildyti'), Length(min=4, message=('Per mažai simbolių'))])
    state = SelectField('Rajonas', choices=[('vln', 'Vilniaus'), ('kns', 'Kauno'), ('klp', 'Klaipėdos')], validators=[DataRequired(message='Lauką būtina užpildyti')])
    zip_code = StringField('Pašto kodas', validators=[DataRequired(message='Lauką būtina užpildyti'), Length(min=4, message=('Per mažai simbolių'))])
    agree = BooleanField('Sutinku gauti šlamštą')
    submit = SubmitField('Submit')
#+end_src
*** templates/base.html
#+begin_src html
<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">

    <title>Superform</title>
  </head>
  <body>
    <br>
        <div class="container">
            {% block content %}
            {% endblock %}
        </div>

    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>
  </body>
</html>
#+end_src
*** templates/form.html
#+begin_src html
{% extends "base.html" %}
{% block content %}

<form method="post" action="#">
    {{ form.csrf_token }}
    <div class="form-row">
      <div class="form-group col-md-6">
        {{ form.email.label(class="form-control-label") }}
        {{ form.email(class="form-control") }}
        {% if form.email.errors %}
        {% for error in form.email.errors %}
          <small><font color="red">{{ error }}</font></small>
        {% endfor %}
        {% endif %}
      </div>
      <div class="form-group col-md-6">
        {{ form.password.label(class="form-control-label") }}
        {{ form.password(class="form-control") }}
        {% if form.password.errors %}
        {% for error in form.password.errors %}
          <small><font color="red">{{ error }}</font></small>
        {% endfor %}
        {% endif %}
      </div>
    </div>
    <div class="form-group">
        {{ form.address1.label(class="form-control-label") }}
        {{ form.address1(class="form-control") }}
        {% if form.address1.errors %}
        {% for error in form.address1.errors %}
          <small><font color="red">{{ error }}</font></small>
        {% endfor %}
        {% endif %}
    </div>
    <div class="form-group">
        {{ form.address2.label(class="form-control-label") }}
        {{ form.address2(class="form-control") }}
        {% if form.address2.errors %}
        {% for error in form.address2.errors %}
          <small><font color="red">{{ error }}</font></small>
        {% endfor %}
        {% endif %}
    </div>
    <div class="form-row">
      <div class="form-group col-md-6">
            {{ form.city.label(class="form-control-label") }}
            {{ form.city(class="form-control") }}
            {% if form.city.errors %}
            {% for error in form.city.errors %}
                <small><font color="red">{{ error }}</font></small>
            {% endfor %}
            {% endif %}
      </div>
      <div class="form-group col-md-4">
            {{ form.state.label(class="form-control-label") }}
            {{ form.state(class="form-control") }}
            {% if form.state.errors %}
            {% for error in form.state.errors %}
                <small><font color="red">{{ error }}</font></small>
            {% endfor %}
            {% endif %}
      </div>
      <div class="form-group col-md-2">
            {{ form.zip_code.label(class="form-control-label") }}
            {{ form.zip_code(class="form-control") }}
            {% if form.zip_code.errors %}
            {% for error in form.zip_code.errors %}
                <small><font color="red">{{ error }}</font></small>
            {% endfor %}
            {% endif %}
      </div>
    </div>
    <div class="form-check">
            {{ form.agree(class="form-check-input") }}
            {{ form.agree.label(class="form-check-label") }}
            {% if form.agree.errors %}
            {% for error in form.agree.errors %}
                <small><font color="red">{{ error }}</font></small>
            {% endfor %}
            {% endif %}
    </div>
    <br>
    {{ form.submit }}
  </form>

{% endblock %}
#+end_src
*** templates/success.html
#+begin_src html
{% extends "base.html" %}
{% block content %}

<h1>Forma užpildyta sėkmingai!</h1><br><br>
<p>Email: {{form.email.data}}</p>
<p>Password: {{form.password.data}}</p>
<p>Adresas:</p>
<p>{{form.address1.data}}</p>
<p>{{form.address2.data}}</p>
<p>{{form.zip_code.data}} {{form.city.data}}</p>
<p>{{form.state.data}} raj.</p>
<p>{{form.agree.data}}</p>

{% endblock %}
#+end_src
* Flask 3 dalis
once again, do pip install flask-sqlalchemy==2.5.1

we will use this, not the current +3 version for some of the projects
listed below to work.

** Duomenų bazės sukūrimas

Flask leidžia mums dirbti su duomenų bazėmis, praktiškai nesitepant
rankų su SQL užklausomis. Viskuo pasirūpina modulis Flask-SQLAlchemy.
Iš principo tai yra SQLAlchemy, optimizuota Flask'ui. Ją galima
įdiegti naudojant pip install Flask-SQLAlchemy komandą.

Susikurkime pirmą duomenų bazę:

#+begin_src python
import os
from flask import Flask
from flask_sqlalchemy import SQLAlchemy

basedir = os.path.abspath(os.path.dirname(__file__))
# pilnas kelias iki šio failo.
app = Flask(__name__)
app.app_context().push()

app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///'+os.path.join(basedir, 'data.sqlite')
# nustatėme, kad mūsų duomenų bazė bus šalia šio failo esants data.sqlite failas
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
# neseksime kiekvienos modifikacijos
db = SQLAlchemy(app)
# sukuriame duomenų bazės objektą
# sukurkime modelį užklausos formai, kuris sukurs duomenų bazėje lentelę


class Message(db.Model):
    # DB lentelei priskiria pavadinimą, jei nenurodysite, priskirs automatiškai pagal klasės pavadinimą.
    __tablename__ = 'messages'
    id = db.Column(db.Integer, primary_key=True)  # stulpelis, kurio reikšmės integer. Taip pat jis bus primary_key.
    name = db.Column(db.String(80), nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    message = db.Column(db.Text, nullable=False)

    def __init__(self, name, email, message):
        self.name = name
        self.email = email
        self.message = message

    def __repr__(self):
        return f'{self.name} - {self.email}'
#+end_src

class Message yra aprašyta mūsų duomenų bazės lentelė. Paleidus šį
failą, duomenų bazė nesusikurs, reikia inicijuoti šį veiksmą iš išorės
(per konsolę arba kitą Python script'ą). Susikurkime dar vieną Python
failą:

#+begin_src python
from app import db, Message

db.create_all()  # sukurs mūsų lentelę DB

# Iš karto inicijuosime testams keletą įrašų:
jonas = Message('Jonas', 'jonas@mail.com', 'Kažkoks labai rimtas atsiliepimas.')
antanas = Message('Antanas', 'antanas@mail.lt', 'Antano nuomonė labai svarbi.')
juozas = Message('Juozas', 'juozukas@friends.lt', 'Aš labai piktas, nes blogai.')
bronius = Message('Bronius', 'bronka@yahoo.com', 'Aš tai linksmas esu, man patinka.')

# Pridėsime šiuos veikėjus į mūsų DB
db.session.add_all([jonas, antanas, juozas, bronius])
# .commit išsaugo pakeitimus
db.session.commit()

print(jonas.id)
print(antanas.id)
print(bronius.id)
print(juozas.id)

# 1
# 2
# 4
# 3
#+end_src

.create_all() įrašė lentelę į DB, inicijuoti testiniai duomenys taip
pat sėkmingai nukeliavo į lentelę, atsispausdinome jų ID, kurie buvo
sugeneruoti automatiškai.

*** Paprastos CRUD operacijos

Susikurkime dar vieną failą, crud operacijų demonstracijai.
Atsispausdinkime visus lentelėje esančius objektus:

#+begin_src python
from app import db, Message

all_messages = Message.query.all()
print(all_messages)

#  [Jonas - jonas@mail.com, Antanas - antanas@mail.lt, Juozas - juozukas@friends.lt, Bronius - bronka@yahoo.com]
#+end_src

Atsispausdinkime vieną iš objektų:

#+begin_src python
message_1 = Message.query.get(1)
print(message_1)

# Jonas - jonas@mail.com
#+end_src


Išfiltruokime objektą pagal nurodytą požymį:

#+begin_src python
message_antanas = Message.query.filter_by(name='Antanas')
print(message_antanas.all())

# [Antanas - antanas@mail.lt]
#+end_src

filter_by išrinks mums visus įrašus, kuriuose name='Antanas'

Pakeiskime Antano el. paštą:

#+begin_src python
antanas = Message.query.get(2)
antanas.email = 'geras.zmogus@lrs.lt'
db.session.add(antanas)
db.session.commit()
print(Message.query.all())

# [Jonas - jonas@mail.com, Antanas - geras.zmogus@lrs.lt, Juozas - juozukas@friends.lt, Bronius - bronka@yahoo.com]
#+end_src

Ištrinkime Joną:

#+begin_src python
jonas = Message.query.get(1)
db.session.delete(jonas)
db.session.commit()
print(Message.query.all())

# [Antanas - geras.zmogus@lrs.lt, Juozas - juozukas@friends.lt, Bronius - bronka@yahoo.com]
#+end_src

** Duomenų bazės migracija

Jeigu mums prireiktų papildyti savo lentelę papildomu stulpeliu,
tiesiog papildžius klasę Message nauja eilute mums nepavyktų, kadangi
duomenų bazė jau inicijuota tokia, kokią nurodėme pirmą kartą. Tą
reikia turėti omenyje, kas kartą, kuriant duomenų bazę stengtis
pasidaryti ją kuo išbaigtesnę. Tuomet ateityje, norint ją papildyti
naujais stulpeliais, ar pakeisti esamų nustatymus, reikės mažiau
migracijos procesų. Susitvarkykime savo projektą taip, kad galėtumėm
vykdyti migracijas:

nustatykime FLASK-APP aplinkos kintamąjį (environment variable). Tą
reikės padaryti Windows komandinėje eilutėje, arba Linux/MacOS
terminale:

*windows* - set FLASK_APP=failas_kuriame_musu_db_modelis.py

*linux/macOS* - ~export FLASK_APP=failas_kuriame_musu_db_modelis.py~

įsitikinkite, kad komandą leidžiate iš to paties katalogo, kuriame
failas su jūsų DB modeliu.

įdiekime Flask-Migrate paketą (pip install Flask-Migrate)

pertvarkykime savo .py failą:

#+begin_src python
import os
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate  # importuojame migracijas

basedir = os.path.abspath(os.path.dirname(__file__))
app = Flask(__name__)

app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///'+os.path.join(basedir, 'data.sqlite')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)

Migrate(app, db)  # Susiejame app ir db.


class Message(db.Model):
    __tablename__ = 'messages'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(80), nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    phone = db.Column(db.String(40), unique=True)  # Papildome duomenų bazės modelį nauju stulpeliu.
    message = db.Column(db.Text, nullable=False)

# prie konstruktoriaus irgi nepamirštame pridėti:
    def __init__(self, name, email, message, phone):
        self.name = name
        self.email = email
        self.message = message
        self.phone = phone

    def __repr__(self):
        return f'{self.name} - {self.email}'
#+end_src

Importus papildėme migracijos 'tarnyba':) Jai nurodėme, kokią
aplikaciją susieti su kokia duomenų baze. Papildėme duomenų bazės
modelį nauju stulpeliu (phone).

Inicijuokime migracijas mūsų projektui su komanda ~flask db init~:

#+begin_src bash
  (flask-kursui) robotautas@robotautas-MS-7A34:~/Dropbox/Flask 3 dalis/Code$ flask db init
  Creating directory /home/robotautas/Dropbox/Flask 3 dalis/Code/migrations ...  done
  Creating directory /home/robotautas/Dropbox/Flask 3 dalis/Code/migrations/versions ...  done
  Generating /home/robotautas/Dropbox/Flask 3 dalis/Code/migrations/alembic.ini ...  done
  Generating /home/robotautas/Dropbox/Flask 3 dalis/Code/migrations/README ...  done
  Generating /home/robotautas/Dropbox/Flask 3 dalis/Code/migrations/env.py ...  done
  Generating /home/robotautas/Dropbox/Flask 3 dalis/Code/migrations/script.py.mako ...  done
  Please edit configuration/connection/logging settings in '/home/robotautas/Dropbox/Flask 3 dalis/Code/migrations/alembic.ini' before proceeding.
  (flask-kursui) robotautas@robotautas-MS-7A34:~/Dropbox/Flask 3 dalis/Code$ ls
  app.py  data.sqlite  migrations  __pycache__  setupdb.py  simple_crud.py  test.py
#+end_src

matome, kad sukurtas migracijų katalogas. Dabar paruoškime savo pirmą
migraciją, ~flask db migrate -m "žinutė atminčiai"~:

(jei tai darome pakartotinai ir matome klaidą "ERROR [flask_migrate]
Error: Target database is not up to date.", reikės prieš tai paleisti
"flask db stamp head")

#+begin_src bash
(flask-kursui) robotautas@robotautas-MS-7A34:~/Dropbox/Flask 3 dalis/Code$ flask db migrate -m "pridėtas stulpelis phone"
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.autogenerate.compare] Detected added column 'messages.phone'
INFO  [alembic.autogenerate.compare] Detected added unique constraint 'None' on '['phone']'
Generating /home/robotautas/Dropbox/Flask 3 dalis/Code/migrations/versions/d31d8cda085d_pridėtas_stulpelis_phone.py ...  done
#+end_src

matome, kad aptikti pakeitimai. Dabar įvykdykime pačią migraciją,
~flask db upgrade~:

#+begin_src bash
(flask-kursui) robotautas@robotautas-MS-7A34:~/Dropbox/Flask 3 dalis/Code$ flask db upgrade
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade  -> d31d8cda085d, pridėtas stulpelis phone
ERROR [root] Error: No support for ALTER of constraints in SQLite dialect

# klaidelę galime ignoruoti, ne visiškas dialekto palaikymas..
#+end_src

patikrinkime, ar suveikė:

#+begin_src python
messages = Message.query.all()

for i in messages:
    random_phone = randint(999999, 10000000)
    i.phone = str(random_phone)
    db.session.add(i)

db.session.commit()

for x in messages:
    print (f'{x.id}, {x.name}, {x.email}, {x.phone}, {x.message}')

# 2, Antanas, geras.zmogus@lrs.lt, 9033639, Antano nuomonė labai svarbi.
# 3, Juozas, juozukas@friends.lt, 2233484, Aš labai piktas, nes blogai.
# 4, Bronius, bronka@yahoo.com, 4211290, Aš tai linksmas esu, man patinka.
#+end_src

Jeigu atkreipėte dėmesį, migracijų procesas labai panašus į GIT procesus.
